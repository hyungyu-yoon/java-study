# Chapter 3 연산자

### 부호/증감 연산자

- 부호 \+(생략) / -
- 연산의 결과는 int
- 증감 연산 ++, --
    - ++피연산자, --피연산자 선 증감
    - 피연산자++, 피연산자-- 후 증감

### 산술 연산자

- \+ , - , * , / , %
- 피연산자에 long이 포함되어 있으면 결과는 long, 그외 int
- 피연산자에 실수 타입이 있으면 결과는 실수 타입

### 오버플로우와 언더플로우

- 오버플로우 - 타입이 허용하는 최대값을 벗어나는 것
- 언더플로우 - 타입이 허용하는 최소값을 벗어나는 것
- 언더플로우/오버플로우가 발생하여도 에러는 발생안하고 최대/최소 값으로 돌아감
- 타입 범위를 생각하여 프로그래밍 할 것

### 정확한 계산은 정수 연산으로

- 정확한 계산은 실수를 사용하지 않는 것이 좋다.
- 부동소수점 계산은 정확한 소숫점을 계산이 안됨

### 나눗셈 연산 후 NaN과 Infinity 처리

- (정수) 5 / 0 일 경우 에러 발생 -> 무한대의 값을 표현할 수 없음
- (실수) 5 / 0.0 -> Infinity , 5 % 0.0 -> NaN 예외 발생안함
- Infinity, NaN 체크 필요 Double.isInfinity(var); Double.isNaN(var);

### 비교 연산자

- 동등 비교 : == , !=
- 크기 비교 : >, >=, <, <=
- 문자열 동등비교 : 변수1.equals(변수2);

### 논리 연산자

- and - &&, &
    - &&는 앞의 연산이 false이면 뒤의 연산 안함, 효율적
- or - ||, |
    - ||는 앞의 연산이 true이면 뒤의 연산 안함, 효율적
- xor - ^
- not - !

### 비트 논리 연산자

- bit 단위로 논리연산을 수행
- AND(논리곱) & : 두 비트가 모두 1일때 1
- OR(논리합) | : 두 비트 중 하나만 1이어도 1
- XOR(배타적 논리합) ^ : 두비트가 서로 반대일 때 1
- NOT(논리 부정) ~ : 보수

### 비트 이동 연산자

- 이동(shift)
    - a << b 정수 a의 각 비트를 b 만큼 왼쪽 이동, 오른쪽 빈자리는 0으로 채움
    - a \>> b 정수 a의 각 비트를 b 만큼 오른쪽 이동, 왼쪽 빈자리는 최상위 부호와 같은 값으로 채움
    - a \>>> b : 정수 a 의 각 비트를 b 만큼 오른쪽으로 이동, 왼쪽 빈자리 0으로 채움

### 대입 연산자

- 우측 피연산자의 값을 좌측 피연산자인 변수에 대입함
- =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=

### 삼항(조건) 연산자

- 피연산 ? true 피연산자 : false 피연산자

### 연산의 방향과 우선순위

- \* / + - ...
- 괄호 먼저 연산하므로 괄호 활용
