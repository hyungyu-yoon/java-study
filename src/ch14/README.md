# Chapter 14 멀티 스레드

### 14.1 멀티 스레드 개념

- 운영체제는 실행 중인 프로그램을 프로세스(Process)로 관리한다.
- 멀티 태스킹은 두 가지 이상의 작업을 동시에 처리하는 것을 말하고, 운영체제는 멀티 프로세스를 생성하여 처리한다.
- 멀티 태스킹은 꼭 멀티 프로세스를 뜻하는 것은 아니다.
- 하나의 프로세스에서 멀티 태스킹을 할 수 있도록 하는 것이 멀티 스레드(multi thread)
- 멀티 프로세스가 프로그램 단위의 멀티 태스킹이라면, 멀티 스레드는 프로그램 내부의 멀티 태스킹이다.
- 멀티 프로세스는 서로 독립적이므로 서로 영향을 미치지 않지만, 멀티 스레드는 프로세스 내부에서 생성되므로 하나의 스레드가 예외를 발생시키면 프로세스가 종료되므로 다른 스레드에게 영향을 준다.
- 프로그램에서 멀티 스레드는 꼭 필요한 기능이므로 반드시 이해하고 활용하자

### 14.2 메인 스레드

- 모든 자바 프로그램은 메인 스레드(main thread)가 main() 메소드를 실행하면서 시작된다.
- 메인 스레드는 main() 메소드의 첫 코드부터 순차적으로 실행하고, main() 메소드의 마지막 코드를 실행하거나 return 문을 만나면 실행을 종료한다.
- 싱글 스레드에서 메인스레드가 종료되면 프로세스도 종료된다.
- 멀티 스레드에서는 실행중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다.
    - 메인 스레드가 먼저 종료되더라도 작업 스레드가 계속 실행 중이라면 프로세스는 종료되지 않는다.

### 14.3 작업 스레드 생성과 실행

- 자바 프로그램은 메인 스레드가 반드시 존재하기 때문에 메인 작업 이외에 추가적인 작업 수만큼 스레드를 생성하면 된다.
- **Thread 클래스로 직접 생성**
    - java.lang 패키지에 있는 Thread 클래스로부터 작업 스레드 객체를 직접 생성
    - Runnable 구현 객체를 매개값으로 갖는 생성자 호출
    - `Thread thread = new Thread(Runable target);`
    - Runnable은 스레드가 작업을 실행할 때 사용하는 인터페이스
    - run() 메소드가 정의되어 있고 구현 클래스는 run()을 재정의해서 스레드가 실행할 코드를 가지고 있어야 한다.
    - 생성된 작업 스레드를 실행하려면 스레드 객체의 start() 메소드를 호출한다.

```text
// 익명 클래스
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        // 스레드 수행 코드
    }
});
thread.start();
```

- **Thread 자식 클래스로 생성**
    - Thread의 자식 객체로 작업 스레드 생성 가능
    - Thread 를 상속한 다음 run() 메소드를 재정의해서 스레드가 실행할 코드를 작성하고 객체 생성

```text
Thread thread = new Thread() {
    @Override
    public void run() {
        //
    }
}
thread.start();
```

### 14.4 스레드 이름

- 스레드는 자신의 이름을 가지고 있다.
- 메인 스레드는 `main`, 작업 스레드는 자동적으로 `Thread-n` 이라는 이름을 가진다.
- 다른 이름을 정하고 싶다면 Thread 클래스의 setName()을 사용한다.
- `thread.setName("스레드 이름");`
- 스레드 이름은 디버깅할 때 어떤 스레드가 작업을 하는지 조사할 목적으로 주로 사용
- 현재 코드를 어떤 스레드가 실행하고 있는지 확인하려면 `Thread.currentThread()` 정적 메소드 사용

### 14.5 스레드 상태

- 스래드 객체를 생성(NEW) 하고 start() 를 하면 실행 대기 상태(RUNNABLE)가 된다.
- 실행 대기하는 스레드는 CPU 스케쥴링에 따라 CPU를 점유하고 run() 메소드를 실행한다.
    - 실행(RUNNING) 상태
- 실행 스레드는 run() 메소드가 모두 실행하기 전에 스케쥴링에 의해 다시 실행 대기 상태로 돌아갈 수 있다.
    - 다른 스레드가 실행 상태가 된다.
- 번갈아 가면서 실행된 스레드의 run() 메소드가 종료되면 더 이상 실행할 코드가 없으므로 실행 종료 상태(TERMINATED) 가 된다.
- 일시 정지 / 실행 대기 / 실행 - 상태 변화 메소드
    - 일시 정지로 보냄
        - sleep: 주어진 시간 동안 스레드를 일시 정지로 만들고 시간이 지나면 실행 대기 상태
        - join: 호출한 스레드는 일시 정지 상태, 실행 대기 상태가 되려면 join() 메소드를 가진 스레드가 종료되어야 함
        - wait: 동기화 블록 내에서 스레드를 일시 정지 상태로 만듬
    - 일시 정지에서 벗어남
        - interrupt: 일시 정지 상태일 경우, InterruptException 을 발생시켜 실행 대기 상태 또는 종료 상태로 만듬
        - notify, notifyAll: wait()로 일시 정지 상태인 스레드를 실행 대기 상태로 만듬
        - yield: 실행 상태에서 다른 스레드에게 실행을 양보하고 실행 대기 상태가 됨
- **주어진 시간 동안 일시 정지**
    - Thread.sleep(long millis) 메소드 사용
- **다른 스레드의 종료를 기다림**
    - 스레드는 다른 스레드와 독립적으로 실행하지만 다른 스레드가 종료될 때까지 기다렸다가 실행 해야하는 경우도 있다.
    - join() 메소드 사용
    - ThreadA 에서 ThreadB 의 join() 메소드를 싱행하면 ThreadA는 ThreadB 가 종료될 때까지 일시 정지한다.
- **다른 스레드에게 실행 양보**
    - 무의미한 무한 반복을 할때 다른 스레드에게 양보해야 하는 경우
    - Thread의 yield() 메소드 사용
    - yield() 를 호출한 스레드는 실행 대기 상태로 돌아가고, 다른 스레드가 실행 상태가 된다.

### 14.6 스레드 동기화

- 한 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하려면 스레드 작업이 끝날때까지 객체에 잠금을 걸면된다.
- 이를 위해 자바는 동기화(synchronized) 메소드를 제공
- 객체 내부에 동기화 메소드와 동기화 블록이 여러 개가 있다면 스레드가 이들 하나를 실행할 때 다른 스레드는 해당 메소드는 물론이고 다른 동기화 메소드 및 블록도 실행할 수 없다.
- 일반 메소드는 실행 가능하다.
- **동기화 메소드 및 블록 선언**
    - 동기화 메소드 선언하는 방 synchronized 키워드
    - `public syncronized void method() { ... }`
    - 메소드가 아닌 일부 영역을 실행하고 싶을 때 메소드 내에
    - `syncronized(공유객체) { ... // 하나의 스레드만 실행하는 영역 }`
- **wait()과 notify()를 이용한 스레드 제어**
    - 경우에 따라서 두 개의 스레드를 교대로 번갈아 가며 실행할 때도 있다.
    - 교대 작업이 필요할 경우 자신의 작업이 끝나면 상대방 스레드를 일시 정지 상태에서 풀어주고 자신은 일시 정지 상태로 만든다.
    - 한 스레드가 작업 완료하면 notify() 메소드를 호출하여 일시 정지 상태에 있는 다른 스레드를 실행 대기로 만들고
    - 자신은 두 번 작업하지 않도록 wait() 메소드를 호출하여 일시 정지 상태로 만든다.
    - notify() 는 wait()에 의해 일시 정지된 스레드 중 한 개를 실행 대기 상태로 만든다.
    - notifyAll() 은 wait()에 의해 정지된 모든 스레드를 실행 대기 상태로 만든다.
    - 두 메소드는 동기화 메소드 또는 동기화 블록내에서만 사용 가능하다.

### 14.7 스레드 안전 종료

- 스레드는 자신의 run() 메소드가 모두 실행되면 자동적으로 종료되지만, 경우에 따라 실행 중인 스레드를 즉시 종료할 필요가 있다.
- 스레드를 안전하게 종료하는 방법은 사용하던 리소스를 정리하고 run() 메소드를 빨리 종료하는 것이다.
- 주로 조건 이용 방법과 interrupt() 메소드 이용 방법을 사용한다.
- **조건 이용**
    - 스레드가 while 문으로 반복 실행할 경우 조건을 이용해서 run() 메소드의 종료를 유도
- **interrupt() 메소드 이용**
    - interrupt() 메소드는 스레드가 일시 정지 상태에 있을 때 InterruptedException 예외를 발생시키는 역할
    - interrupt() 메소드는 어떤 이유로든 일시 정지 상태가 되어야 한다.
    - 일시 정지를 만들지 않고 interrupt() 를 사용하려면
        - Thread의 정적 메소드 interrupted()
        - 인스턴스 메서드의 isInterrupted()
        - 메소드는 interrupt() 호출 여부를 리턴한다.

### 14.8 데몬 스레드

- 데몬(daemon) 스레드는 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드
- 주 스레드가 종료되면 자동 종료
- 스레드를 데몬으로 만들기 위해서는 주 스레드가 데몬이 될 스레드의 setDaemon(true) 를 호출하면 된다.

### 14.9 스레드풀

- 병렬 작업 처리가 많아지면 스레드의 개수가 폭증하여 CPU가 바빠지고 메모리 사용량이 늘어난다.
- 스레드 폭증을 막으려면 스레드 풀(thread pool) 을 사용하는 것이 좋다.
- 스레드 풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해놓고 작업 큐(Queue)에 들어오는 작업들을 스레드가 하나씩 맡아 처리하는 방식이다.
- 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리한다.
- **스레드풀 생성**
    - java.util.concurrent 패키지에서 ExecutorService 인터페이스와 Executors 클래스를 제공
    - Executors 의 두 정적 메서드
        - newCachedThreadPool() : 초기 수: O, 코어 수: O, 최대 수: Integer.MAX_VALUE
        - newFixedThreadPoll(int nThreads): 초기 수: 0, 코어 수: 생성된 수, 최대 수: nThreads
    - 초기 수는 스레드풀이 생성될 때 기본적으로 생성되는 스레드 수
    - 코어 수는 스레드가 증가된 후 사용되지 않는 스레드를 제거할 때 최소한 풀에서 유지하는 스레드 수
    - 최대 수는 증가되는 스레드의 한도 수
    - 외에 ThreadPoolExecutor 로 스레드플 생성 가능
- **스레드풀 종료**
    - 스레드풀의 스레드는 기본적으로 데몬 스레드가 아니기에 main 스레드가 종료되더라도 작업을 처리하기 위해 계속 실행 상태로 남음
    - 스레드풀의 모든 스레드를 종료하려면 ExecutorService 의 두 메소드 실행
        - void shutdown() : 현재 처리 중인 작업뿐만 아니라 작업 큐에 대기하고 있는 모든 작업을 처리한뒤 스레드풀 종료시킴
        - List\<Runnable\> shutdownNow(): 현재 작업 중인 스레드를 interrupt 해서 작업을 중지시키고 스레드풀 종료 시킴. 리턴값은 미처리된 작업 목록
- **작업 생성과 처리 요청**
    - 하나의 작업은 Runnable 또는 Callable 구현 객체로 표현
    - 둘의 차이점은 처리 완료 후 리턴이 있느냐 없느냐이다.
    - Runnable 의 run() 은 리턴값이 없고, Callable의 call() 은 리턴값이 있다. 리턴 타입은 Callable\<T\> 에서 지정한 T
    - 작업 처리 요청이란 ExecutorService의 작업 큐에 Runnable 또는 Callable 객체를 넣는 행위
        - void execute(Runnable command) : Runnable을 작업 큐에 저장, 리턴 안함
        - Future\<T\> submit(Callable\<T\> task): Callable을 작업 큐에 저장, Future 리턴