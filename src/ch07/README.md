# Chapter 7 상속

### 7.1 상속 개념

- 상속(Inheritance) : 부모가 자식에게 물려주는 행위
- 객체지향에서 부모 클래스의 필드와 메소드를 자식 클래스에게 물려줄 수 있다.
- 상속은 이미 잘 개발된 클래스를 재사용해서 중복되는 코드를 줄여주고 개발 시간을 단축시킨다.
- 클래스 수정을 최소화 할 수 있다.
    - 부모 클래스 수정 시 자식 클래스도 수정된 필드, 메서드 사용 가능

### 7.2 클래스 상속

- 자식 클래스에서 어떤 부모로 부터 상속받을지 선택 가능
- public class Child **extends** Parent { ... }
- 다중 상속을 허용하지 않는다. 단 하나의 부모 클래스만 가능

### 7.3 부모 생성자 호출

- 자식 객체를 생성하면 부모 객체가 먼저 생성된 다음에 자식 객체가 생성된다.
- 자식 생성자의 맨 첫 줄에는 부모 생성자를 호출하는 super()가 숨겨져 있다. (컴파일 과정에서 자동 추가)

```text
public child() {
    super(); // 부모 생성자 호출
}
```

- 부모 클래스에 기본 생성자가 없다면 자식 생성자 선언에서 컴파일 에러가 발생
    - 부모 클래스의 기본 생성자를 private로 만들면 상속 제한 효과

### 7.4 메소드 재정의

- 자식 클래스에서 부모 클래스의 메서드를 필요에 의해 재정의 하여 사용할 수 있다.
- 이를 메소드 오버라이딩(Overriding) 이라고 한다.
- **메소드 오버라이딩**
    - 상속된 메소드를 자식 클래스에서 재정의 하는 것
    - 주의사항
        - 부모 메소드의 선언부(리턴 타입, 메소드 이름, 매개변수) 와 동일해야한다.
        - 접근 제한을 더 강하게 오버라이딩 할 수 없다. (public -> private 불가)
        - 새로운 예외를 throws 할 수 없다
    - 정확하게 오버라이딩이 되었는지 체크해주는 @Override 어노테이션 제공
        - 컴파일 단계에서 체크하여 문제 있으면 컴파일 에러
- **부모 메소드 호출**
    - 부모 메소드의 로직을 재활용하고 추가로 작성하고 싶은 경우
    - 자식 메소드 내에서 부모 메소드 호출 `super.methodName()`
    - 자식 메소드의 실행부의 어디서든 호출 가능

### 7.5 final 클래스와 final 메소드

- **final 클래스**
    - 클래스 앞에 final 키워드를 붙이면 더 이상 상속할 수 없다.
    - ex) String class `public final class String {...}`
- **final 메소드**
    - 메소드를 final 로 만들면 오버라이딩 할 수 없는 메소드가 된다.
    - 자식 클래스에서 final 메소드 재정의 불가능
    - `public final int sum(...){ ... }`

### 7.6 protected 접근 제한자

- protected는 상속과 관련이 있고, public과 default 중간쯤에 해당하는 접근제한을 한다.
- 필드, 생성자, 메소드 제한 / 같은 패키지이거나 자식 객체(다른 패키지에 생성되었더라도)만 사용 가능

### 7.7 타입 변환

- **자동 타입 변환**
    - `부모타입 변수 = 자식타입객체;`일 때 자동 타입 변환
    - 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다.
    - 부모 타입이 아니더라도 상속 계층에서 상위 타입이라면 자동 타입 변환이 일어날 수 있다.
    - 부모 타입으로 자동 타입 변환되면 부모 클래스에 있는 필드와 메서드만 접근 가능
    - 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로 한정한다.
    - 자식 클래스에서 오버라이딩된 메소드가 있다면 오버라이딩된 메소드가 호출된다. 다형성 관련
- **강제 타입 변환**
    - 부모 타입 객체를 자식 타입으로 강제 타입 변환
    - `자식터압 변수 = (자식타입) 부모타입객체;` 강제 타입으로 변환 가능
    - 자식객체가 부모 타입으로 자동 변환된 후 다시 자식 타입으로 변환할 때 강제 타입 변환 가능
    - 부모 타입으로 강제 타입 변환시 부모 타입에 선언된 필드와 메서드만 사용가능하므로 자식 타입에 선언된 필드와 메서드를 꼭 사용하려면 자식타입으로 강제 타입변 환을 해야한다.

### 7.8 다형성

- 다형성: 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
- 객체 사용 방법이 동일하다는 것은 동일한 메소드를 가지고 있다는 뜻
- 다형성의 구현 - 자동 타입 변환과 메서드 재정의
- **필드 다형성**
    - 필드 타입은 동일하지만 대입되는 객체가 달라져서 실행 결과가 다양하게 나올 수 있는 것
- **매개변수 다형성**
    - 다형성은 필드보다 메서드 호출할 때 많이 발생
    - 메소드가 클래스 타입의 매개변수를 가지고 있을 경우, 호출할 때 동일한 타입의 객체를 제공하는 것이 정석이지만 자식 객체를 제공할 수 있다. 다형성

### 7.9 객체 타입 확인

- 객체의 타입을 확인하고자 할 때 instancof 연산자 사용
- `객체 instanceof 타입` : 해당 타입이면 true, 아니면 false 반환
- 자바 12 부터는 instanceof 결과가 true 일 경우 우측 타입 변수를 사용할 수 있기 때문에 강제 타입 변환 필요없다.

```text
if (parent instanceof Child child) {
    // child.~~~
}
```

### 7.10 추상 클래스

- 사전적 의미의 추상(abstract) : 실체 간에 공통되는 것을 추출한 것
    - ex) 새, 곤충, 물고기 => 동물
- **추상 클래스**
    - 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스를 추상 클래스라 한다.
    - 추상 클래스는 실체 클래스의 부모 역할
    - 추상 클래스는 new 연산자로 객체를 직접 생성할 수 없다.
    - 추상클래스는 새로운 실체 클래스를 만들기 위한 부모 클래스로만 사용된다. extends 뒤에만 올 수 있다.
- **추상 클래스 선언**
    - 클래스 선언에 `abstract` 키워드를 붙이면 추상 클래스가 된다.
    - 추상 클래스도 필드, 메서드를 선언할 수 있다.
    - 자식 객체가 생성될 때 super() 로 추상 클래스의 생성자가 호출ㄷ괴기 때문에 생성자도 반드시 있어야 한다.
- **추상 메소드와 재정의**
    - 추상 클래스에서 추상 메소드를 선언할 수 있다.
    - `abstract 리턴타입 메소드명(...);`
    - 추상 메소드는 자식 클래스의 공통 메소드라는 것만 정의할 뿐, 실행 내용을 가지지 않는다.
    - 메소드가 하나라도 추상메서드라면 클래스는 추상 클래스여야 한다.
- 추상 클래스 사용이유?
  - 구현의 강제화
  - 규격에 맞는 설계 구현 가능
    - 미리 정의된 공통적으로 필요한 필드, 메서드를 기능만 구현 할 수 있다.
- [추상 팩토리 패턴](https://refactoring.guru/ko/design-patterns/abstract-factory)
- [템플릿 메서드 패턴](https://refactoring.guru/ko/design-patterns/template-method)

### 7.11 봉인된 클래스

- 자바 15부터 무분별한 자식 클래스 생성을 방지하기 위해 봉인된(sealed) 클래스가 도입되었다.
- sealed 키워드를 사용하면 permits 키워드 뒤에 상속 가능한 자식 클래스를 지정해야 한다.
- `public sealed class Person permits Employee, Manager {...}`
- 봉인된 클래스를 상속하는 자식 클래스는 final 또는 non-sealed 키워드를 선언하거나 sealed 선언으로 또 다른 봉인 클래스로 선언해야 한다.
- `public final class Employee extends Person {...}`
- `public non-sealed class Manager extends Person {...}`
- final 클래스는 더 이상 상속 불가능 하지만 non-sealed 클래스는 가능하다.
- `public class Director extends Manager {...}`