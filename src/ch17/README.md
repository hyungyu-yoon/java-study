# Chapter 17 스트림 요소 처리

### 17.1 스트림이란?

- 자바 8부터 컬렉션 및 배열의 요소를 반복 처리하기 위해 스트림(Stream) 을 사용할 수 있다.
- 스트림은 요소들이 하나씩 흘러가면서 처리된다는 의미를 가지고 있다.
- `Stream<String> stream = list.stream();` Stream 객체 생성
- `stream.forEach(item -> // item 처리 );`
- Stream은 Iterator 와 비슷한 반복자이지만, 차이점이 있다.
    - 내부 반복자이므로 처리 속도가 빠르고 병렬 처리에 효율적이다.
    - 람다식으로 다양한 요소 처리를 정의할 수 있다.
    - 중간 처리와 최종 처리를 수행하도록 파이프 라인을 형성할 수 있다.

### 17.2 내부 반복자

- for문과 Iterator는 컬렉션의 요소를 컬렉션 바깥쪽으로 반복해서 가져와 처리하는데, 이것을 외부 반복자라고 한다.
- 스트림은 요소 처리 방법을 컬렉션 내부로 주입시켜서 요소를 반복 처리하는데, 이것을 내부 반복자라고 한다.
- 외부 반복자는 컬렉션의 요소를 외부로 가져오는 코드와 처리하는 코드를 모두 개발자 코드가 가지고 있어야한다.
- 내부 반복자는 개발자 코드에서 제공한 데이터 처리 코드(람다식)을 가지고 컬렉션 내부에서 요소를 반복 처리한다.
- 내부 반복자는 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 병렬 작업할 수 있다.
- parallelStream() 메소드로 병렬 처리

### 17.3 중간 처리와 최종 처리

- 스트림은 하나 이상 연결될 수 있다.
- 스트림 -> 중간 처리 -> ... -> 최종 처리 = 스트림 파이프라인
- 스트림은 최종 처리를 위해 요소를 필터링, 매핑, 정렬하는 작업을 수행
- 최종 처리는 정제된 요소들을 반복하거나, 집계 작업을 수행
- 스트림 파이프라인을 구성할 때 주의할 점은 파이프라인의 맨 끝에는 반드시 최종 처리 부분이 있어야 한다.
- 최종 처리가 없다면 오리지널 및 중간 처리 스트림은 동작하지 않는다. (lazy evaluation)

### 17.4 리소스로부터 스트림 얻기

- java.util.stream 패키지에 스트림 인터페이스들이 있다.
- BaseStream을 인터페이스를 부모로 한 자식 인터페이스들은 다음과 같은 상속 관계를 이룬다.
    - BaseStream
        - Stream
        - IntStream
        - LongStream
        - DoubleStream
- BaseStream 에는 모든 스트림에서 사용할 수 있는 공통 메서드들이 정의
- Stream 은 객체 요소를 처리하는 스트림
- IntStream, LongStream, DoubleStream 은 각각 기본 타입 int, long, double 요소를 처리하는 스트림
- **컬렉션으로부터 스트림 얻기**
    - java.util.Collection 인터페이스는 스트림과 parallelStream() 메소드를 가지고 있기 때문에 자식 인터페이스인 List와 Set 인터페이스를 구현한 모든 컬렉션에서 객체 스트림을
      얻을 수 있다.
- **배열로부터 스트림 얻기**
    - java.util.Ararys 클래스를 이용하면 다양한 종류의 배열로부터 스트림을 얻을 수 있다.
- **숫자 범위로부터 스트림 얻기**
    - IntStream 또는 LongStream의 정적 메소드인 range() 와 rangeClosed() 메소드를 이용하면 특정 범위의 정수 스트림을 얻을 수 있다.
    - 첫 번째 매개값은 시작 수, 두 번째 매개값은 끝 수인데, 끝 수를 포함하지 않으면 range(), 포함하면 rangeClosed() 를 사용
- **파일로부터 스트림 얻기**
    - java.nio.Files 의 lines() 메소드를 이용하면 텍스트 파일의 행 단위 스트림을 얻을 수 있다.
    - 텍스트 파일에서 한 행씩 읽고 처리할 때 유용하게 사용할 수 있다.

### 17.5 요소 걸러내기(필터링)

- 필터링은 요소를 걸러내는 중간 처리 기능
- distinct() 와 filter() 가 있다.
- distinct() 메소드는 요소의 중복을 제거한다.
    - 객체 스트림일 경우, equals 메소드의 리턴 값이 true 이면 동일한 요소로 판단
    - IntStream, LongStream, DoubleStream 은 같은 값일 경우 중복 제거
- filter() 메소드는 매개값으로 주어진 Predicate 가 true를 리턴하는 요소만 필터링

### 17.6 요소 변환(매핑)

- 매핑(mapping) 은 스트림의 요소를 다른 요소로 변환하는 중간 처리 기능
- 매핑 메소드는 mapXxx(), asDoubleStream(), asLongStream(), boxed(), flatMapXxx() 등이 있다.
- **요소를 다른 요소로 변환**
    - mapXxx() 메소드는 요소를 다른 요소로 변환한 새로운 스트림을 반환
    - 기본 타입 간의 변환이거나 기본 타입 요소를 래퍼 객체 요소로 변환하려면 asLongStream(), asDoubleStream(), boxed() 사용
- **요소를 복수 개의 요소로 반환**
    - flatMapXxx() 메소드는 하나의 요소를 복수 개의 요소들로 변환한 새로운 스트림을 리턴

### 17.7 요소 정렬

- 정렬은 요소를 오름차순 또는 내림차순으로 정렬하는 중간 처리 기능
- sorted() ~
- **Comparable 구현 객체의 정렬**
    - 스트림의 요소가 객체일 경우 객체가 Comparable을 구현하고 있어야만 sorted() 메소드 사용하여 정렬 가능
    - 그렇지 않으면 ClassCastException 발생
- **Comparator를 이용한 정렬**
    - 요소 객체가 Comparable 을 구현하고 있지 않다면, 비교자를 제공하면 요소를 정렬시킬 수 있다.
    - 람다식으로 간단하게 작성 가능
        - `(o1, o2) -> { ... }` o1이 o2 보다 작으면 음수, 같으면 0, 크면 양수 리턴

### 17.8 요소를 하나씩 처리(루핑)

- 루핑은 스트림에서 요소를 하나씩 반복해서 가져와 처리하는 것
- 루핑 메소드에는 peek() 와 forEach() 가 있다.
- peek() 은 중간처리 메소드, forEach() 는 최종 처리 메소드

### 17.9 요소 조건 만족 여부(매칭)

- 매칭은 요소들이 특정 조건에 만족하는지 여부를 조사하는 최종 처리 기능
- allMatch() 모든 요소가 만족하면 true
- anyMatch() 최소 하나라도 만족하면 true
- noneMatch() 모든 요소가 만족하지 않으면 true

### 17.10 요소 기본 집계

- 집계는 최종 처리 기능으로 요소들을 처리해서 카운팅, 합계, 평균값, 최대값, 최소값 등과 같이 하나의 값으로 산출하는 것
- 대량의 데이터를 가공해서 하나의 값으로 축소하는 리덕션
- **스트림이 제공하는 기본 집계**
    - count() 요소 개수
    - findFirst() 첫 번째 요소
    - max() 최대 요소
    - min() 최소 요소
    - average() 평균
    - sum() 총합
    - 집계 메소드는 Optional 을 리턴, get, getAsDouble ... 을 호출해야 최종 값을 얻는다.
- **Optional 클래스**
    - 집계값이 존재하지 않을 경우 디폴트 값을 설정하거나 집계 값을 처리하는 Consumer 를 등록할 수 있다.
    - isPresent() 집계값이 있는지 여부
    - orElse() 집계값이 없을 경우 디폴트 값
    - ifPresent(Consumer) 집계 값이 있을 경우 Consumer 에서 처리
    - 컬렉션의 요소는 동적으로 추가되는 경우가 많다.
    - Optional 메소드를 사용해 예외 케이스를 막을 수 있다.

### 17.11 요소 커스텀 집계

- 다양한 집계 결과물을 만들 수 있드록 reduce() 메소드 제공
- 매개값인 BinaryOperator 는 두 개의 매개값을 받아 하나의 값을 리턴하는 apply() 메소드를 갖고 있다.
    - identify 매개값이 주어지면 이 값을 디폴트로 리턴

### 17.12 요소 수집

- 스트림은 요소들을 필터링 또는 매핑한 후 요소들을 수집하는 최종 처리 메소드인 collect() 를 제공
- 필요한 요소만 컬렉션에 담거나, 요소들을 그룹핑한 후 집계 가능
- **필터링 한 요소 수집**
    - Stream 의 collect 메소드는 필터링 또는 매핑된 요소들을 새로운 컬렉션에 수집하고, 이 컬렉션을 리턴한다.
    - R collect(Collector\<T,A,R\> collector)
    - 타입 파라미터의 T는 요소, A는 누적기, R은 요소가 저장될 컬렉션
    - toList(), toSet(), toMap()
- **요소 그룹핑**
    - 컬렉션의 요소들을 그룹핑해서 Map 객체를 생성하는 기능 제공
    - Collectors.groupingBy(Funtion\<T, K\> classifier) 메소드
        - Function을 이용해 T를 K로 매핑하고, K를 키로 해 List\<T\> 를 갖는 값으로 Map 컬렉션 생성
    - Collectors.groupingBy() 메소드는 그룹핑 후 매핑 및 집계를 수행할 수 있도록 두 번째 매개값인 Collector 를 가질 수 있다.
    - mapping, averagingDouble, counting, maxBy, minBy reducing ...

### 17.13 요소 병렬 처리

- 요소 병렬 처리 (Parallel Operation) 란 멀티 코어 CPU 환경에서 전체 요소를 분할해서 각각의 코어가 병렬적으로 처리하는 것
- 요소 병렬 처리의 목적은 작업 처리 시간을 줄이는 것에 있다.;
- 자바에서는 병렬 스트림을 제공
- **동시성과 병렬성**
    - 멀티 스레드는 동시성(Concurrency) 또는 병렬성(Parallelism) 으로 실행되므로 용어에 대해 정확한 이해 필요
    - 동시성은 멀티 작업을 위해 멀티 스레드가 하나의 코어에서 번갈아 가며 실행하는 것
    - 병렬성은 멀티 작업을 위해 멀티 코어를 각각 이용해서 병렬로 실행하는 것
    - 동시성은 한 시점에 하나의 작업만 실행
    - 병렬성은 한 시점에 여러 개의 작업을 병렬로 실행
    - 병렬성은 데이터 병렬성과 작업 병렬성으로 구분
    - **데이터 병렬성**
        - 전체 데이터를 분할해서 서브 데이터셋으로 만들고 이 서브 데이터셋들을 병렬 처리해서 작업을 빨리 끝내는 것 (자바 병렬 스트림 구현)
    - **작업 병렬성**
        - 서로 다른 작업을 병렬 처리하는 것
- **포크조인 프레임워크**
    - 자바 병렬 스트림은 요소들을 병렬 처리하기 위해 포크조인 프레임워크(ForkJoin) 를 사용한다.
    - 포크조인 프레임워크는 포크 단계에서 전체 요소들을 서브 요소셋으로 분할하고, 각각의 서브 요소셋을 멀티 코어에서 병렬처리한다.
    - 조인 단계에서는 서브 결과를 결합해 최종 결과를 만들어 낸다.
    - 병렬 처리 스트림은 포크 단계에서 요소를 순서대로 분할하지 않음
    - 포크조인 프레임워크는 병렬 처리를 위해 스레드풀을 사용한다.
    - 각각의 코어에서 서브 요소셋을 처리하는 것은 작업 스레드가 해야 하므로 스레드 관리가 필요하다.
    - 포크조인 프레임워크는 ExecutorService의 ForkJoinPool 을 사용해서 작업 스레드 관리
- **병렬 스트림 사용**
    - 자바 병렬 스트림을 사용할 경우 백그라운드에서 포크조인 프레임워크가 사용되어 쉽게 병렬 처리 가능
    - parallelStream(), parallel()
- **병렬 처리 성능**
    - 스트림 병렬 처리가 스트림 순차 처리보다 항상 실행 성능이 좋다고 판단해서는 안된다.
    - 별렬 처리에 영향을 미치는 3가지 요인을 살펴보아야 한다.
        - **요소의 수와 요소당 처리 시간**
            - 컬렉션에 전체 요소의 수가 적고 요소당 처리 시간이 짧으면 일반 스트림이 병렬 스트림보다 빠를 수 있다.
            - 포크 및 조인 단계, 스레드 풀 생성하는 추가적 비용 존재
        - **스트림 소스의 종류**
            - ArrayList 와 배열은 인덱스로 요소를 관리하기 때문에 포크 단계에서 요소를 쉽게 분리할 수 있어 병렬 처리 시간이 절약된다.
            - HashSet, TreeSet 은 요소 분리가 쉽지 않고 LinkedList 역시 링크를 따라가야 하므로 요소 분리가 쉽지 않음
                - 상대적으로 병렬처리가 늦다.
        - **코어의 수**
            - CPU 코어의 수가 많으면 많을 수록 병렬 처리 스트림의 성능은 좋아진다.
            - 코어의 수가 적을 경우 일반 스트림이 더 빠를 수 있다.
            - 병렬 스트림은 스레드 수가 증가하여 동시성이 많이 일어나므로 오히려 느려짐
